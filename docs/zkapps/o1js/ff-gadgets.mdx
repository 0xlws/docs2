---
title: Gadgets for Foreign Field Operations
hide_title: true
description: Foreign field operations gadgets in o1js.
keywords:
  - gadgets
  - bitwise
  - o1js
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Gadgets for foreign field operations.
   *
   * A _foreign field_ is a finite field different from the native field of the proof system.
   *
   * The `ForeignField` namespace exposes operations like modular addition and multiplication,
   * which work for any finite field of size less than 2^259.
   *
   * Foreign field elements are represented as 3 limbs of native field elements.
   * Each limb holds 88 bits of the total, in little-endian order.
   *
   * All `ForeignField` gadgets expect that their input limbs are constrained to the range [0, 2^88).
   * Range checks on outputs are added by the gadget itself.
   */
  ForeignField: {
    /**
     * Foreign field addition: `x + y mod f`
     *
     * The modulus `f` does not need to be prime.
     *
     * Inputs and outputs are 3-tuples of native Fields.
     * Each input limb is assumed to be in the range [0, 2^88), and the gadget is invalid if this is not the case.
     * The result limbs are guaranteed to be in the same range.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(9n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * // range check x and y
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     *
     * // compute x + y mod 17
     * let z = ForeignField.add(x, y, 17n);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = 9 + 10 mod 17
     * ```
     *
     * **Warning**: The gadget does not assume that inputs are reduced modulo f,
     * and does not prove that the result is reduced modulo f.
     * It only guarantees that the result is in the correct residue class.
     *
     * @param x left summand
     * @param y right summand
     * @param f modulus
     * @returns x + y mod f
     */
    add(x: Field3, y: Field3, f: bigint) {
      return ForeignField.add(x, y, f);
    },

    /**
     * Foreign field subtraction: `x - y mod f`
     *
     * See {@link ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x - y < -f`, where the result cannot be brought back to a positive number by adding `f` once.
     */
    sub(x: Field3, y: Field3, f: bigint) {
      return ForeignField.sub(x, y, f);
    },

    /**
     * Foreign field sum: `xs[0] + signs[0] * xs[1] + ... + signs[n-1] * xs[n] mod f`
     *
     * This gadget takes a list of inputs and a list of signs (of size one less than the inputs),
     * and computes a chain of additions or subtractions, depending on the sign.
     * A sign is of type `1n | -1n`, where `1n` represents addition and `-1n` represents subtraction.
     *
     * **Note**: For 3 or more inputs, `sum()` uses fewer constraints than a sequence of `add()` and `sub()` calls,
     * because we can avoid range checks on intermediate results.
     *
     * See {@link ForeignField.add} for assumptions on inputs.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(4n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(5n));
     * let z = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * // range check x, y, z
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     * Gadgets.multiRangeCheck(z);
     *
     * // compute x + y - z mod 17
     * let sum = ForeignField.sum([x, y, z], [1n, -1n], 17n);
     *
     * Provable.log(sum); // ['16', '0', '0'] = limb representation of 16 = 4 + 5 - 10 mod 17
     * ```
     */
    sum(xs: Field3[], signs: (1n | -1n)[], f: bigint) {
      return ForeignField.sum(xs, signs, f);
    },

    /**
     * Foreign field multiplication: `x * y mod f`
     *
     * The modulus `f` does not need to be prime, but has to be smaller than 2^259.
     *
     * **Assumptions**: In addition to the assumption that input limbs are in the range [0, 2^88), as in all foreign field gadgets,
     * this assumes an additional bound on the inputs: `x * y < 2^264 * p`, where p is the native modulus.
     * We usually assert this bound by proving that `x[2] < f[2] + 1`, where `x[2]` is the most significant limb of x.
     * To do this, use an 88-bit range check on `2^88 - x[2] - (f[2] + 1)`, and same for y.
     * The implication is that x and y are _almost_ reduced modulo f.
     *
     * **Warning**: This gadget does not add the extra bound check on the result.
     * So, to use the result in another foreign field multiplication, you have to add the bound check on it yourself, again.
     *
     * @example
     * ```ts
     * // example modulus: secp256k1 prime
     * let f = (1n << 256n) - (1n << 32n) - 0b1111010001n;
     *
     * let x = Provable.witness(Field3.provable, () => Field3.from(f - 1n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(f - 2n));
     *
     * // range check x, y
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     *
     * // prove additional bounds
     * let x2Bound = x[2].add((1n << 88n) - 1n - (f >> 176n));
     * let y2Bound = y[2].add((1n << 88n) - 1n - (f >> 176n));
     * Gadgets.multiRangeCheck([x2Bound, y2Bound, Field(0n)]);
     *
     * // compute x * y mod f
     * let z = ForeignField.mul(x, y, f);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = (-1)*(-2) mod f
     * ```
     */
    mul(x: Field3, y: Field3, f: bigint) {
      return ForeignField.mul(x, y, f);
    },

    /**
     * Foreign field inverse: `x^(-1) mod f`
     *
     * See {@link ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     */
    inv(x: Field3, f: bigint) {
      return ForeignField.inv(x, f);
    },

    /**
     * Foreign field division: `x * y^(-1) mod f`
     *
     * See {@link ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     *
     * @throws Different than {@link ForeignField.mul}, this fails on unreduced input `x`, because it checks that `x === (x/y)*y` and the right side will be reduced.
     */
    div(x: Field3, y: Field3, f: bigint) {
      return ForeignField.div(x, y, f);
    },
  },

  /**
   * Helper methods to interact with 3-limb vectors of Fields.
   *
   * **Note:** This interface does not contain any provable methods.
   */
  Field3,
};

export namespace Gadgets {
  /**
   * A 3-tuple of Fields, representing a 3-limb bigint.
   */
  export type Field3 = [Field, Field, Field];
}