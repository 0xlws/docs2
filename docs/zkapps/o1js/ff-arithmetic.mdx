---
title: Foreign Field Arthmetic
hide_title: true
description: Foreign field arithmetic gadgets in o1js.
keywords:
  - gadgets
  - ff
  - foreign field
  - o1js
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Foreign Field Arthmetic

A foreign field is a finite field different from the native Field of the proof system. The [ForeignField](https://github.com/o1-labs/o1js/blob/main/src/lib/gadgets/foreign-field.ts) namespace exposes operations like modular addition and multiplication that work for any finite field of size less than 2^259. 

Foreign field elements are represented as three limbs of native Field elements.

- Each limb holds 88 bits of the total in little-endian order.
- All `ForeignField` gadgets expect that their input limbs are constrained to the range [0, 2^88).
- The gadget itself adds range checks on outputs.

In o1js, foreign field arithmetic operations are implemented as gadgets.

- [add()](#add)
- [sub()](#sub)
- [neg()](#neg)
- [sum()](#sum)

## add()

```ts
add(x: Field3, y: Field3, f: bigint) {
      return ForeignField.add(x, y, f);
    }
```

The foreign field `add()` gadget:

- Guarantees only that the result is in the correct residue class.
- Does not assume that inputs are reduced modulo `f`.
- Does not prove that the result is reduced modulo `f`.
- Does not require that the modulus `f` is prime.
- Uses inputs and outputs that are 3-tuples of native Fields.
- Requires that each input limb must be in the range `[0, 2^88)`.
- Guarantees that the result limbs are in the same range.

Example:

```ts
let x = Provable.witness(Field3.provable, () => Field3.from(9n));
let y = Provable.witness(Field3.provable, () => Field3.from(10n));

// range check x and y
Gadgets.multiRangeCheck(x);
Gadgets.multiRangeCheck(y);

// compute x + y mod 17
let z = ForeignField.add(x, y, 17n);

Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = 9 + 10 mod 17
```

where:

- `x` is the left summand
- `y` is the right summand
- `f` is the modulus

Returns `x + y mod f`.

## sub()

```ts
x - y mod f
```



     *
     * See {@link ForeignField.add} for assumptions and usage examples.
     *
     * @throws fails if `x - y < -f`, where the result cannot be brought back to a positive number by adding `f` once.
     */
    sub(x: Field3, y: Field3, f: bigint) {
      return ForeignField.sub(x, y, f);
    },

    /**
     * Foreign field sum: `xs[0] + signs[0] * xs[1] + ... + signs[n-1] * xs[n] mod f`
     *
     * This gadget takes a list of inputs and a list of signs (of size one less than the inputs),
     * and computes a chain of additions or subtractions, depending on the sign.
     * A sign is of type `1n | -1n`, where `1n` represents addition and `-1n` represents subtraction.
     *
     * **Note**: For 3 or more inputs, `sum()` uses fewer constraints than a sequence of `add()` and `sub()` calls,
     * because we can avoid range checks on intermediate results.
     *
     * See {@link ForeignField.add} for assumptions on inputs.
     *
     * @example
     * ```ts
     * let x = Provable.witness(Field3.provable, () => Field3.from(4n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(5n));
     * let z = Provable.witness(Field3.provable, () => Field3.from(10n));
     *
     * // range check x, y, z
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     * Gadgets.multiRangeCheck(z);
     *
     * // compute x + y - z mod 17
     * let sum = ForeignField.sum([x, y, z], [1n, -1n], 17n);
     *
     * Provable.log(sum); // ['16', '0', '0'] = limb representation of 16 = 4 + 5 - 10 mod 17
     * ```
     */
    sum(xs: Field3[], signs: (1n | -1n)[], f: bigint) {
      return ForeignField.sum(xs, signs, f);
    },

    /**
     * Foreign field multiplication: `x * y mod f`
     *
     * The modulus `f` does not need to be prime, but has to be smaller than 2^259.
     *
     * **Assumptions**: In addition to the assumption that input limbs are in the range [0, 2^88), as in all foreign field gadgets,
     * this assumes an additional bound on the inputs: `x * y < 2^264 * p`, where p is the native modulus.
     * We usually assert this bound by proving that `x[2] < f[2] + 1`, where `x[2]` is the most significant limb of x.
     * To do this, use an 88-bit range check on `2^88 - x[2] - (f[2] + 1)`, and same for y.
     * The implication is that x and y are _almost_ reduced modulo f.
     *
     * **Warning**: This gadget does not add the extra bound check on the result.
     * So, to use the result in another foreign field multiplication, you have to add the bound check on it yourself, again.
     *
     * @example
     * ```ts
     * // example modulus: secp256k1 prime
     * let f = (1n << 256n) - (1n << 32n) - 0b1111010001n;
     *
     * let x = Provable.witness(Field3.provable, () => Field3.from(f - 1n));
     * let y = Provable.witness(Field3.provable, () => Field3.from(f - 2n));
     *
     * // range check x, y
     * Gadgets.multiRangeCheck(x);
     * Gadgets.multiRangeCheck(y);
     *
     * // prove additional bounds
     * let x2Bound = x[2].add((1n << 88n) - 1n - (f >> 176n));
     * let y2Bound = y[2].add((1n << 88n) - 1n - (f >> 176n));
     * Gadgets.multiRangeCheck([x2Bound, y2Bound, Field(0n)]);
     *
     * // compute x * y mod f
     * let z = ForeignField.mul(x, y, f);
     *
     * Provable.log(z); // ['2', '0', '0'] = limb representation of 2 = (-1)*(-2) mod f
     * ```
     */
    mul(x: Field3, y: Field3, f: bigint) {
      return ForeignField.mul(x, y, f);
    },

    /**
     * Foreign field inverse: `x^(-1) mod f`
     *
     * See {@link ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     */
    inv(x: Field3, f: bigint) {
      return ForeignField.inv(x, f);
    },

    /**
     * Foreign field division: `x * y^(-1) mod f`
     *
     * See {@link ForeignField.mul} for assumptions on inputs and usage examples.
     *
     * This gadget adds an extra bound check on the result, so it can be used directly in another foreign field multiplication.
     *
     * @throws Different than {@link ForeignField.mul}, this fails on unreduced input `x`, because it checks that `x === (x/y)*y` and the right side will be reduced.
     */
    div(x: Field3, y: Field3, f: bigint) {
      return ForeignField.div(x, y, f);
    },
  },

  /**
   * Helper methods to interact with 3-limb vectors of Fields.
   *
   * **Note:** This interface does not contain any provable methods.
   */
  Field3,
};
