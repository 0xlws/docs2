---
title: Bitwise Operations
hide_title: true
description: Bitwise operations in o1js are implemented as gadgets.
keywords:
  - gadgets
  - bitwise operations
  - o1js
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Bitwise Operations

In o1js, bitwise operations are implemented as [gadgets](/zkapps/o1js/gadgets).

- [and()](#and)
- [not()](#not)
- [xor()](#xor)
- [addMod32()](#addmod32)
- [divMod32()](#divmod32)
- [leftShift32()](#leftshift32)
- [leftShift64()](#leftshift64)
- [rightShift32()](#rightshift32)
- [rightShift64()](#rightshift64)
- [rotate32()](#rotate32)
- [rotate64()](#rotate64)
- [rangeCheck32()](#rangecheck32)
- [rangeCheck64()](#rangecheck64)
- [multiRangeCheck()](#multirangecheck)
- [compactMultiRangeCheck()](#compactmultirangecheck)

## and()

```ts
and(a: Field, b: Field, length: number) => Field
```

The bitwise `and()` gadget on Field elements is equivalent to the [bitwise AND (&)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND) operator in JavaScript. It is a provable method for bitwise and operations.

The AND operation:

- Compares two bits and returns 1 only if both bits are 1. Returns 0 if either bit is not 1.
- Constrains both input values to fit into `paddedLength` bits. 
- Requires both Field elements to fit into `2^paddedLength - 1`.
- Guarantees that the output has at most `paddedLength` bits.

For details about the implementation, see [AND](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#and) in the Mina book.

The `length` parameter:

- Defines how many bits to compare. 
- Rounds `length` to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`.
- A larger `length` parameter adds more constraints.

With `length = 2` (`paddedLength = 16`), the AND operation fails for any input that is larger than `2**16`.

Example:

```ts
let a = Field(3);    // ... 000011
let b = Field(5);    // ... 000101
let c = Gadgets.and(a, b, 2);    // ... 000001
c.assertEquals(1);
```

## not()

```ts
not(a: Field, length: number, checked: boolean) => Field
```

The bitwise `not()` gadget on Field elements is similar to the [Bitwise NOT (~)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT) operator in JavaScript. It is a provable method for bitwise negation.

The NOT operation:

- Changes each bit to its opposite:
  - Returns 1 in each bit position if the corresponding bit of the operand is 0. 
  - Returns 0 if the corresponding bit of the operand is 1.
- Requires the input value to be 254 bits or less.
- Operates only over the number of bits specified by the `length` parameter.
    - The `length` parameter defines how many bits to NOT.
    - A larger `length` parameter adds more constraints.
- Is implemented in two different ways:
    - If the `checked` parameter is set to `false`, it is implemented as a subtraction of the input from the all-ones bitmask (all the bits in a binary sequence are set to 1). This approach is more efficient, but does not check the length of the input. If the `checked` parameter is not provided, the default implementation uses `false`.
    - If the `checked` parameter is set to `true`, the [xor()](#xor) gadget is reused with a second argument to be an all-ones bitmask of the same length. This approach is less efficient because it needs as many rows as an XOR requires for a single negation, but comes with the advantage of making sure the input is of a certain length.

For implementation details, see [NOT](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#not) in the Mina book.

Example NOT-ing 4 bits with the unchecked version:

```ts
let a = Field(0b0101);
let b = Gadgets.not(a,4,false);

b.assertEquals(0b1010);
```

Example NOT-ing 4 bits with the checked version using `xor()`:

```ts
let a = Field(0b0101);
let b = Gadgets.not(a,4,true);

b.assertEquals(0b1010);
```

## xor()

```ts
xor(a: Field, b: Field, length: number) => Field
```

The `xor()` gadget is equivalent to the [Bitwise XOR (^)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR) operator in JavaScript. It is a provable method to support bitwise XOR operations for native Field elements. 

The XOR operation:

- Compares two bits and returns 1 if they differ. Returns 0 if the two bits are equal.
- Recursively builds a chain of XOR gates. 
- Verifies that each XOR gate can verify at most 16 bits.
- Adds another XOR gate to the chain if your input elements exceed 16 bits.
- Rounds `length` to the nearest multiple of 16, `paddedLength = ceil(length / 16) * 16`.
- Constrains input values to fit into `paddedLength` bits. 
- Requires that both Field elements fit into `2^paddedLength`.
    For example, `length = 2` (`paddedLength = 16`) fails for any input that is larger than `2**16`.
- Guarantees the output has at most `paddedLength` bits.

The `length` parameter defines how many bits to compare. When choosing the value of the `length` parameter, be sure to carefully weigh the trade-off between an increased number of constraints and security:
- A larger `length` parameter adds more constraints.
- A smaller `length` allows the verifier to infer the length of the original input data. For example, it will be smaller than 16 bits if only one XOR gate is used.

For details about the implementation, see [XOR](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#xor-1) in the Mina book.

Example:

```ts
let a = Field(0b0101);
let b = Field(0b0011);

let c = Gadgets.xor(a, b, 4); // xor-ing 4 bits
c.assertEquals(0b0110);
```


## addMod32()

```ts
addMod32(a: Field, b: Field) => Field
```

The `addMod32()` operation adds two Field elements in the range `[0, 2^64)` and returns the result modulo `2^32`. It is a helper method to interact with 3-limb vectors of Fields.

The operation:

- Is addition modulo `2^32`.
- Asserts that the result is in the range `[0, 2^32)` using [rangeCheck32()](#rangeCheck32).
- Uses [divMod32()](#divmod32) internally by adding the two Field elements,  decomposing the result into `remainder` and `quotient`, and returning the `remainder`.
- Requires both inputs to be in the range `[0, 2^64)`. 
  - If the operation is called with non-range-checked inputs, the sum `a + b` can overflow the native field and the gadget can succeed but return an invalid result.

Example:

```ts
let a = Field(8n);
let b = Field(1n << 32n);

Gadgets.addMod32(a, b).assertEquals(Field(8n));
```

## divMod32()

```ts
divMod32(a: Field, b: Field) => Field
```

The `divMod32()` gadget adds two Field elements in the range `[0, 2^64]` and returns the result modulo `2^32` (the remainder and quotient of the operation). It is a helper method to interact with 3-limb vectors of Fields.

The operation:

- Is division modulo `2^32` to provide the remainder of the division when a number is divided by `2^32`.
- Decomposes a Field element in the range `[0, 2^64]` into two 32-bit limbs, `remainder` and `quotient`, using this equation: `n = quotient * 2^32 + remainder`.
- Acts as a proof that the input is in the range [0, 2^64).
- Asserts that both `remainder` and `quotient` are in the range `[0, 2^32]` using [rangeCheck32()](#rangeCheck32).

Example:

```ts
let n = Field((1n << 32n) + 8n)
let { remainder, quotient } = Gadgets.divMod32(n);
// remainder = 8, quotient = 1

n.assertEquals(quotient.mul(1n << 32n).add(remainder));
```

## leftShift32()

```ts
leftShift32(field: Field, bits: number) => Field
```

The `leftShift32()` gadget is a provable method that supports the bitwise shifting operation that moves the bits of a binary number to the left. Unlike rotation, the bits that fall off at the end are discarded and the vacant positions are filled with zeros.

The operation:

- Performs a left shift operation on a Field element.
- Shifts bits to the left and discards the overflowing bits.
- Performs these operations with the big-endian 32-bit representation of the number, where the most significant (32nd) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 32 bits. You can use [rangeCheck32](#rangecheck32).

Example:

```ts
const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
const y = Gadgets.leftShift32(x, 2); // left shift by 2 bits
y.assertEquals(0b110000); // 48 in binary
```

## leftShift64()

```ts
leftShift64(field: Field, bits: number) => Field
```

The `leftShift64()` gadget is a provable method that supports the bitwise shifting operation that moves the bits of a binary number to the left. Unlike rotation, the bits that fall off at the end are discarded and the vacant positions are filled with zeros.

The operation:

- Performs a left shift operation on a Field element.
- Shifts bits to the left and discards the overflowing bits.
- Performs these operations with the big-endian 64-bit representation of the number, where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 64 bits. You can use [rangeCheck64](#rangecheck64).

Example:

```ts
const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
const y = Gadgets.leftShift(x, 2); // left shift by 2 bits
y.assertEquals(0b110000); // 48 in binary

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
leftShift(xLarge, 32); // throws an error since input exceeds 64 bits
``

## rightShift32()

```ts
rightShift32(field: Field, bits: number) => Field
```

The `rightShift32()` gadget is a provable method that supports the bitwise shifting operation that moves the bits of a binary number to the right. Unlike rotation, the bits that fall off at the end are discarded and the vacant positions are filled with zeros.

The operation:

- Performs a right shift operation on a Field element.
- Shifts bits to the right and discards the overflowing bits.
- Performs these operations with the big-endian 32-bit representation of the number, where the most significant (32nd) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 32 bits. You can use [rangeCheck32](#rangecheck32).

Example:

```ts
const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
const y = Gadgets.leftShift(x, 2); // left shift by 2 bits
y.assertEquals(0b110000); // 48 in binary

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
leftShift(xLarge, 32); // throws an error since input exceeds 64 bits
```

## rightShift64()

```ts
rightShift64(field: Field, bits: number) => Field
```

The `rightShift64()` gadget is a provable method that supports the bitwise shifting operation that moves the bits of a binary number to the right. Unlike [rotate32()](#rotate32) and [rotate64()](#rotate64), the bits that fall off at the end are discarded and the vacant positions are filled with zeros.

The operation:

- Performs a right shift operation on a Field element.
- Shifts bits to the right and discards the overflowing bits.
- Performs these operations with the big-endian 64-bit representation of the number, where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 64 bits. You can use [rangeCheck64](#rangecheck64).

Example:
```ts
const x = Provable.witness(Field, () => Field(0b001100)); // 12 in binary
const y = Gadgets.rightShift64(x, 2); // right shift by 2 bits
y.assertEquals(0b000011); // 3 in binary

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
rightShift64(xLarge, 32); // throws an error since input exceeds 64 bits
```

## rotate32()

```ts
rotate32(field: Field, bits: number, direction: 'left' | 'right' = 'left') {
  return rotate32(field, bits, direction);
},
```

The `rotate32()` gadget operates like the [Left shift (<<)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Left_shift) and [Right shift (>>)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Right_shift) operators in JavaScript except the bits are circulated to the opposite end of a 32-bit representation rather than being discarded. It is a provable method to support bitwise left or right rotation for native Field elements. 

The operation:

- Shifts bits to the left or the right.
- The rotate left operation (ROL) shifts bits to the left. The bits that fall off the leftmost side wrap around and reappear on the right end.
- The rotate right operation (ROR) shifts bits to the right. The bits that fall off the rightmost side wrap around and reappear on the left end.
- Performs these operations with the big-endian 32-bit representation of the number, where the most significant (32nd) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 32 bits. You can use [rangeCheck32](#rangecheck32).

For implementation details, see [ROTATION](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation) in the Mina book.

Example:

```ts
const x = Provable.witness(Field, () => Field(0b001100));
const y = Gadgets.rotate32(x, 2, 'left'); // left rotation by 2 bits
const z = Gadgets.rotate32(x, 2, 'right'); // right rotation by 2 bits
y.assertEquals(0b110000);
z.assertEquals(0b000011);

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
Gadgets.rotate32(xLarge, 32, "left"); // throws an error since input exceeds 32 bits
```

## rotate64()

```ts
rotate64(field: Field, bits: number, direction: 'left' | 'right' = 'left') {
  return rotate64(field, bits, direction);
},
```

The `rotate64()` gadget operates like the [Left shift (<<)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Left_shift) and [Right shift (>>)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Right_shift) operators in JavaScript except the bits are circulated to the opposite end of a 64-bit representation rather than being discarded. It is a provable method to support bitwise left or right rotation for native Field elements. 

The operation:

- Shifts bits to the left or the right. 
  - The rotate left operation (ROL) shifts bits to the left. The bits that fall off the leftmost side wrap around and reappear on the rightmost side.
  - The rotate right operation (ROR) shifts bits to the right. The bits that fall off the rightmost side wrap around and reappear on the leftmost side.
- Performs these operations with the big-endian 64-bit representation of the number, where the most significant (64th) bit is on the left end and the least significant bit is on the right end.
- Requires values that are range checked to 64 bits. You can use [rangeCheck64](#rangecheck64).

For implementation details, see [ROTATION](https://o1-labs.github.io/proof-systems/specs/kimchi.html?highlight=gates#rotation) in the Mina book.

Example:

```ts
const x = Provable.witness(Field, () => Field(0b001100));
const y = Gadgets.rotate64(x, 2, 'left'); // left rotation by 2 bits
const z = Gadgets.rotate64(x, 2, 'right'); // right rotation by 2 bits
y.assertEquals(0b110000);
z.assertEquals(0b000011);

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
Gadgets.rotate64(xLarge, 32, "left"); // throws an error since input exceeds 64 bits
```

## rangecheck32()

```ts
rangeCheck32(x: Field) => void
```

The `rangecheck32()` gadget is a helper function that asserts that the input value is in the range `[0, 2^32)`.

The operation:

- Proves that the field element can be represented with 32 bits.
- Interprets small "negative" field element inputs as large integers close to the field size, so they do not pass the 32-bit check. To prove that a value lies in the int32 range `[-2^31, 2^31)`, you can use `rangeCheck32(x.add(1n << 31n))`.

Example:

```ts
const x = Provable.witness(Field, () => Field(12345678n));
Gadgets.rangeCheck32(x); // successfully proves 32-bit range

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
Gadgets.rangeCheck32(xLarge); // throws an error since input exceeds 32 bits
```

## rangecheck64()

```ts
rangeCheck64(x: Field) => void
```

The `rangecheck64()` gadget  is a helper function that asserts that the input value is in the range `[0, 2^64)`.

The operation:

- Proves that the field element can be represented with 64 bits.
- Throws an errors if the field element exceeds 64 bits.
- Interprets small "negative" field element inputs as large integers close to the field size, so they don't pass the 64-bit check. To prove that a value lies in the int64 range `[-2^63, 2^63)`, use `rangeCheck64(x.add(1n << 63n))`.

Example:

```ts
const x = Provable.witness(Field, () => Field(12345678n));
Gadgets.rangeCheck64(x); // successfully proves 64-bit range

const xLarge = Provable.witness(Field, () => Field(12345678901234567890123456789012345678n));
Gadgets.rangeCheck64(xLarge); // throws an error since input exceeds 64 bits
```

## multiRangeCheck()

```ts
multiRangeCheck([x, y, z])
```

The `multiRangeCheck()` gadget is a building block for non-native arithmetic with BigInt of size up to 264 bits. It is a provable method for efficient 64-bit range checks using lookup tables.

The operation is a helper function that:

- Takes 4 rows and checks `88*3/4 = 66` bits per row, so is slightly more efficient than [64-bit range checks](#rangecheck64).
- Supports BigInts up to 264 bits (`3x88-bit`) that supports foreign field multiplication with moduli up to `2^259`.
- Requires input values to be 88 bits or less.

Example:

```ts
multiRangeCheck(limbs: Field3) {
  multiRangeCheck(limbs);
}
```

## compactMultiRangeCheck()

```ts
compactMultiRangeCheck(xy: Field, z: Field) => [Field, Field, Field];
```

The bitwise `compactMultiRangeCheck()` gadget is a variant of [multiRangeCheck](#multirangecheck) where the first two variables are passed in combined form `xy = x + 2^88*y`.

The operation:

- Splits `xy` into `x` and `y`.
- Proves that `xy = x + 2^88*y`.
- Proves that `x, y, z` are all in the range `[0, 2^88)`.
- Returns the split form `[x, y, z]`.
- Throws an error if `xy` exceeds `2*88 = 176` bits or if `z` exceeds 88 bits.

Example:

```ts
compactMultiRangeCheck(xy: Field, z: Field) {
  return compactMultiRangeCheck(xy, z);
},
```