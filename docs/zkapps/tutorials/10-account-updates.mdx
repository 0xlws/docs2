---
title: 'Tutorial 10: Account Updates'
hide_title: true
sidebar_label: 'Tutorial 10: Account Updates'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.9.3.

:::

# Tutorial 10: Account Updates

## Permissions, Preconditions, and Composability

## Overview:

Each zkApp transaction constructed in SnarkyJS is composed of [AccountUpdates](../snarkyjs-reference/classes/AccountUpdate), a set of instructions for the Mina network.

Each AccountUpdate can make assertions about its account, apply updates to its account, as well as make assertions about its child AccountUpdates.

Transactions are structured as a list of trees of AccountUpdates - applied with a ["pre-order"](https://en.wikipedia.org/wiki/Tree_traversal) traversal.

Many of the core features of zkApps - permissions, preconditions, composability, and tokens - are each implemented through the use of AccountUpdates. In this tutorial, you learn all of these except tokens and assertions on account update layouts.

To learn more, see these advanced SnarkyJS docs:

* [Permissions](../advanced-snarkyjs/permissions)
* [Preconditions](../advanced-snarkyjs/on-chain-values)

## AccountUpdate contents

Each [AccountUpdate](../snarkyjs-reference/classes/AccountUpdate) has these components:

* `PublicKey`: The account address for the account update
* `TokenId`: By default, the Mina TokenId. Together, TokenId and PublicKey uniquely determine the account.
* `Preconditions`: What needs to be true for the AccountUpdate to be applied. Corresponds to assertions in a SnarkyJS method.
* `Updates`: Things that are changed by the AccountUpdate. Can include the zkApp state, permissions, and verification key.
* `Balance change`: Any changes to the balance
* `Authorization`: How the zkApp is authorized; can be either a proof (corresponding to the verification key on the account) or a signature.

There are some other components we'll discuss in a later tutorial:

* `MayUseToken`: Whether the zkApp has permissions to manipulate its token.
* `Layout`: Allows for assertions about the structure of an AccountUpdate.

## AccountUpdates for a non-user-upgradable zkApp

Now, you can start building an example zkApp to explore permissions, preconditions, and composability with AccountUpdates.

To visualize transactions, we'll be using the library `mina-transaction-visualizer`. To use this in your own zkApp, install with npm with `npm install mina-transaction-visualizer --save`.

You can find the full source code for this [Account Updates](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/10-account-updates) tutorial in the codebase repo.

### Smart Contracts

You will build two smart contracts to use in your example:

First, [ProofsOnlyZkApp.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/10-account-updates/src/ProofsOnlyZkApp.ts).

You will configure this zkApp to be modifiable only by using proofs. For this example, the zkApp is not upgradable after it is deployed. This means that while someone must own the private key to deploy the zkApp itself - after it is deployed, only the rules in the zkApp determine how the zkApp functions. The private key is no longer useful for anything.

This zkApp also has methods that call other methods, so we can explore how that impacts a transaction's AccountUpdates.

Start by adding the main contents of the zkApp:

```typescript

export class ProofsOnlyZkApp extends SmartContract {
  @state(Field) num = State<Field>();
  @state(Field) calls = State<Field>();

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      setDelegate: Permissions.proof(),
      setPermissions: Permissions.proof(),
      setVerificationKey: Permissions.proof(),
      setZkappUri: Permissions.proof(),
      setTokenSymbol: Permissions.proof(),
      incrementNonce: Permissions.proof(),
      setVotingFor: Permissions.proof(),
      setTiming: Permissions.proof(),
    });
  }

  @method init() {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertFalse();

    super.init();
    this.num.set(Field(1));
    this.calls.set(Field(0));
  }

  ...
```

This code configures the zkApp as described and initializes the zkApp with the values you want. 

:::caution
Note you assert that `provedState` is `false` in `init()` to ensure that `init()` cannot be called again after the zkApp is set up. Without this, your zkApp could be reset by anyone calling the `init()` method on your zkApp and is recommended for most zkApps. 
:::

Next, add two functions:

```typescript
  ...

  @method add(incrementBy: Field) {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const num = this.num.get();
    this.num.assertEquals(num);
    this.num.set(num.add(incrementBy));

    this.incrementCalls();
  }

  @method incrementCalls() {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const calls = this.calls.get();
    this.calls.assertEquals(calls);
    this.calls.set(calls.add(Field(1)));
  }

  ...
```

:::caution
In each of these methods, you are also asserting `provedState` is `true` to ensure the zkApp was initialized as expected because `provedState` becomes true after `init` is called and is recommended for most zkApps.
:::

Note you are also having the `add()` method call the `incrementCalls()` method, to see how this is reflected in the `add()` transaction's AccountUpdate structure.

Finally, add one more function, `callSecondary()` that calls a different zkApp:

```typescript
  ...

  @method callSecondary(secondaryAddr: PublicKey) {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const secondaryContract = new SecondaryZkApp(secondaryAddr);

    const num = this.num.get();
    this.num.assertEquals(num);

    secondaryContract.add(num);

    // NOTE this gets the state at the start of the transaction
    this.num.set(secondaryContract.num.get());

    this.incrementCalls();
  }
}
```

This takes the address of our other zkApp, `SecondaryZkApp`, and calls a method on it. Note that the impact of calling that method occurs after this set of AccountUpdates - so when you call `secondaryContract.num.get()` that gets the value before this transaction is applied.

Last, to look briefly at [SecondaryZkApp.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/10-account-updates/src/SecondaryZkApp.ts), you have contents:

```typescript
export class SecondaryZkApp extends SmartContract {
  @state(Field) num = State<Field>();

  @method init() {
    super.init();

    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertFalse();

    this.num.set(Field(12));
  }

  @method add(incrementBy: Field) {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const num = this.num.get();
    this.num.assertEquals(num);
    this.num.set(num.add(incrementBy));
  }
}

```

You declare functions for initializing the account and the `add` method that is called from the earlier `ProofOnlyZkApp`.

### Running our Smart Contracts and Visualizing the AccountUpdates

Now it's time to learn about the [main.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/10-account-updates/src/main.ts) file that creates transactions with the earlier smart contracts and the account update visualizations it creates.

First, import the transaction visualizer:

```typescript
...
import { showTxn, saveTxn, printTxn } from 'mina-transaction-visualizer';
...
```

This provides three functions:

```typescript
// creates a png file of a transaction, and opens it in a local image viewer
async showTxn(txn: Mina.Transaction, name: string, legend: Legend)

// creates a png file of a transaction, and saves it to a path
saveTxn(txn: Mina.Transaction, name: string, legend: Legend, path: string)

// prints a nicely formatted view of a transaction
showTxn(txn: Mina.Transaction, name: string, legend: Legend)

// with legend type, to replace public keys with human readable strings:
type Legend = { [pk: string]: string };

```

Now build the legend as follows:

```typescript
  const legend = {
    [proofsOnlyAddr.toBase58()]: 'proofsOnlyZkApp',
    [secondaryAddr.toBase58()]: 'secondaryZkApp',
    [deployerAccount.toPublicKey().toBase58()]: 'deployer',
  };
```

Then deploy your smart contracts as follows and visualize the transaction:

```typescript
  const deployTxn = await Mina.transaction(deployerAccount, () => {
    AccountUpdate.fundNewAccount(deployerAccount, 2);
    proofsOnlyInstance.deploy();
    secondaryInstance.deploy();
  });

  await deploy_txn.prove();
  deploy_txn.sign([ deployerKey, proofsOnlySk, secondarySk ]);

  await showTxn(deploy_txn, 'deploy_txn', legend);

  await deploy_txn.send();
```

This yields the following visualization of `deploy_txn`. 


<img src="/img/tutorial-10-deploy_txn.png" width="100%" />

This is best opened in a new tab to read the contents ([link](/img/tutorial-10-deploy_txn.png)).

The deploy transaction includes 5 accountUpdates. In order from left to right;

1. This accountUpdate takes the new account fee from the deployer for deploying the zkApps. Note the `-2` on the `balanceChange` field
2. This update deploys the `proofsOnlyZkApp` instance. Note the permissions, all set to the values in the zkApp's deploy field, and the `preconditions` asserting the nonce, so the transaction can't be applied more than once.
3. This update initializes the `proofsOnlyZkApp`. Note the precondition that it can't already be in a proved state.
4. This update deploys an instance of `secondaryZkApp`. Note the permissions here are set to default values, in contrast to the deployment in the `proofsOnlyZkApp` example.
5. This update initializes the `secondaryZkApp` instance.

When the transaction is run on-chain, all of these account updates are checked and applied. Note that there is no actual "execution" of each AccountUpdate provided - instead, each AccountUpdate includes an associated signature or proof, corresponding to the verification key in the zkApp.

Next, call `add` on your instance of `proofsOnlyZkApp`:

```typescript
  const txn1 = await Mina.transaction(deployerAccount, () => {
    proofsOnlyInstance.add(Field(4));
  });

  await txn1.prove();

  await showTxn(txn1, 'txn1', legend);

  await txn1.send();
```

This yields the following visualization of `txn1`


<img src="/img/tutorial-10-txn1.png" width="100%" />

See download link [here](/img/tutorial-10-txn1.png).

Now there are two AccountUpdates, where one is a child of the other. The parent corresponds to the `add` method call - and the child corresponds to the `this.incrementCalls()` call that the parent makes. 

One update is the child because it was called from the parent - which also implies that the parent has the child included as part of its proof. You can read more on parent / child account updates [here](../how-to-write-a-zkapp#payments-and-more-on-public-inputs).

As a reminder, this corresponds to code: 

```typescript
  ...
  @method add(incrementBy: Field) {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const num = this.num.get();
    this.num.assertEquals(num);
    this.num.set(num.add(incrementBy));

    this.incrementCalls();
  }

  @method incrementCalls() {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const calls = this.calls.get();
    this.calls.assertEquals(calls);
    this.calls.set(calls.add(Field(1)));
  }
  ...
```

You can note in the account updates that in the first update, you're updating the state of `appState[0]` to `5` (matching the `this.num.set` in the `add` contract), and in the second update, you're updating `appState[1]` to `1` (matching the `this.calls.set` in the `incrementCalls` contract).

Lastly, call `callSecondary` on your instance of `proofsOnlyZkApp`:

```typescript
  const txn2 = await Mina.transaction(deployerAccount, () => {
    proofsOnlyInstance.callSecondary(secondaryAddr);
  });

  await txn2.prove();

  await showTxn(txn2, 'txn2', legend);
  await saveTxn(deploy_txn, 'deploy_txn', legend, './txn2.png');

  await txn2.send();
```

This yields the following visualization of `txn2`

<img src="/img/tutorial-10-txn2.png" width="100%" />

See download link [here](/img/tutorial-10-txn2.png).

And a quick reminder of the code for `callSecondary`:

```typescript
  @method callSecondary(secondaryAddr: PublicKey) {
    this.account.provedState.assertEquals(this.account.provedState.get());
    this.account.provedState.get().assertTrue();

    const secondaryContract = new SecondaryZkApp(secondaryAddr);

    const num = this.num.get();
    this.num.assertEquals(num);

    secondaryContract.add(num);

    // NOTE this gets the state at the start of the transaction
    this.num.set(secondaryContract.num.get());

    this.incrementCalls();
  }
```

This call is producing 3 accountUpdates - one for `callSecondary` (the parent) - one for `secondaryZkApp.add` (the left child) - and one for `incrementCalls` (the right child).

Following the note in the comment, note that `callSecondary` sets `this.num` to `12` - the value of `secondaryContract` at the "start" of the transaction.

## Conclusion

Congratulations! You have explored the core features of AccountUpdates and learned about visualizing the AccountUpdates for a set of transactions. You can build more complicated transactions that involve multiple zkApps. This tutorial builds a foundational understanding of how SnarkyJS and zkApps work to enable permissions, preconditions, and composability.

