---
title: 'Tutorial 11: Advanced Account Updates'
hide_title: true
sidebar_label: 'Tutorial 11: Advanced Account Updates'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.9.6.

:::

# Tutorial 11: Advanced Account Updates

## zkAppManager Accounts and Tokens

## Overview:

In the last tutorial, you learned how zkApp transactions are composed of AccountUpdates and about the structure of Account Updates.

In this tutorial, you learn about more advanced features of account updates. Namely tokens, zkApp Manager Accounts, and account update assertions.

An earlier tutorial covered how each token is associated with a manager account and how the manager account determines rules for token minting, burning, and transfer.

Under the hood, what is happening is actually a bit more general than that. The Manager Account for a token actually controls all properties of token accounts.

## zkApp Manager Accounts & Tokens

For an Account Update to be able to modify state (including sending tokens) on a token account, two things must be true:

1. The account update must meet the criteria of the permissions on the zkApp account itself. If the zkApp Account is setup with the `proof` permission, this means the Account Update proof must pass the verification key in the account
2. The account update must set `mayUseToken` to True. An account update on a token account cannot set this property to true itself however. It must get its account update “approved” by its corresponding manager account. The manager account can approve accounts based on its `access` permission.

## zkApp Token Management

As an example, you can write a token that can approve a zkApp account to send tokens from itself to another zkApp.

To implement this, you would have 3 contracts:

1. `MyToken`: The token contract. On instantiation, serves as the zkAppManagerContract for all instances of the token.
2. `TokenUser`: A zkApp contract which will manage tokens. This one is instantiated on the Mina (default) tokenId
3. `TokenHolder`: A zkApp contract which will store tokens on behalf of the `TokenUser` contract. This one is instantiated on the `MyToken` instance TokenId.

You can find the full code [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/11-advanced-account-updates/).

A token standard library is in the above which will abstract much of these details away too for standard use. The illustration here though should help explain what that library is doing and how to think about zkAppManagerAccounts in detail.

These contracts can be setup as follows:

```typescript
const myTokenInstance = new MyToken(myTokenAddr);
const tokenUserInstance = new TokenUser(tokenUserAddr);
const tokenHolderInstance = new TokenHolder(
  tokenUserAddr,
  myTokenInstance.token.id
);
```

And deployed as follows:

```typescript
const deploy_txn = await Mina.transaction(deployerAddr, () => {
  let feePayerUpdate = AccountUpdate.fundNewAccount(deployerAddr, 4);
  feePayerUpdate.send({ to: myTokenAddr, amount: accountFee });

  myTokenInstance.deploy();
  tokenUserInstance.deploy();
  tokenHolderInstance.deploy();

  myTokenInstance.approveDeploy(tokenHolderInstance.self);
});
```

The special thing to note here is the `approveDeploy(...)` on the `myTokenInstance`. Because `tokenHolderInstance` is going to exist as a token account, it needs approval to be deployed.

The `myTokenInstance.approveDeploy(...)` code is as follows:

```typescript
  @method approveDeploy(deployUpdate: AccountUpdate) {
    this.approve(deployUpdate, AccountUpdate.Layout.NoChildren);

    // check that balance change is zero
    let balanceChange = Int64.fromObject(deployUpdate.body.balanceChange);
    balanceChange.assertEquals(Int64.from(0));
  }
```

This checks that the deployUpdate is a single account update, with no children - and that it isn't creating any additional tokens, and is starting out with a balance of zero.

Next, here is an example of sending tokens from the `tokenUser`/`tokenHolder` to another account:

```typescript
const txn2 = await Mina.transaction(deployerAddr, () => {
  let feePayerUpdate = AccountUpdate.fundNewAccount(deployerAddr, 1);
  tokenUserInstance.sendMyTokens(UInt64.from(100), deployerAddr);
});
```

The `fundNewAccount` call is included as the deployer account in this case doesn't have an existing token account.

`tokenUserInstance.sendMyTokens(...)` is implemented as follows:

```typescript
  @method sendMyTokens(
    amount: UInt64,
    destination: PublicKey
  ) {
    const tokenHolder = this.tokenHolder;
    tokenHolder.transferAway(amount);
    this.tokenContract.approveTransfer(tokenHolder.self, destination);
  }
```

Which calls the `transferAway` contract on `tokenHolder`:

```typescript
  @method transferAway(amount: UInt64) {
    // TODO: in a real zkApp, here would be application-specific checks for whether we want to allow sending tokens

    this.balance.subInPlace(amount);
    this.self.body.mayUseToken = AccountUpdate.MayUseToken.ParentsOwnToken;
  }
```

And is approved by the token contract's `approveTransfer`:

```typescript
  @method approveTransfer(transferUpdate: AccountUpdate, receiver: PublicKey) {
    this.approve(transferUpdate, AccountUpdate.Layout.NoChildren);

    let balanceChange = Int64.fromObject(transferUpdate.body.balanceChange);

    // assert that the balance change is negative
    balanceChange.isPositive().not().assertTrue();

    // move the same amount to the receiver
    this.token.mint({ address: receiver, amount: balanceChange.magnitude });
  }

```

The account updates for this transcation looks as follows:

<img src="/img/tutorial-11-txn2.png" width="95%" />

This shows both the account update for the fee payment - and the main tree which does the token operations. You can see the call to `tokenUser` at top, followed by a call to `myToken`, that is doing the approving. This approves two account updates - one of which is taking tokens away from the `tokenUser` - and the other of which is sending tokens to the deployer account. Both have the `mayUseToken` field set to `parentsOwnToken`.

Because of the logic in the `myToken` approval account, the balances must match out between these two account updates. Which it does, and so a valid `proof` can be constructed.

As noted above, a token standard library is in the above which will abstract much of these details away too for standard use.

## Conclusion

Congratulations! You have explored some of the advanced features of AccountUpdates. You can now build with Token zkAppManagers.

To see how to apply some of this in a more complex example, see the "wrappedMinaToken" implementation [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/11-advanced-account-updates/src/wrappedMinaMain.ts)

and learned about visualizing the AccountUpdates for a set of transactions. You can build more complicated transactions that involve multiple zkApps. This tutorial builds a foundational understanding of how SnarkyJS and zkApps work to enable permissions, preconditions, and composability.
