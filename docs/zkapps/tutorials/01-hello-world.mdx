---
title: 'Tutorial 1: Hello World'
hide_title: true
sidebar_label: 'Tutorial 1: Hello World'
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

:::note

This tutorial was last tested with [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) 0.6.4 and [SnarkyJS](https://www.npmjs.com/package/snarkyjs) 0.8.0.

:::

# Tutorial 1: Hello World

## Overview

This Hello World tutorial helps you get started with SnarkyJS, zkApps, and programming with zero-knowledge proofs. 

In this step-by-step tutorial, you learn to code a zkApp from start to finish.

You will: 

- Write a basic smart contract that stores a number as on-chain state.
- The contract logic allows this number to be replaced only by its square; for example, 2 -> 4 -> 16, and so on. 
- Create a project using the [Mina zkApp CLI](https://www.npmjs.com/package/zkapp-cli)
- Write our smart contract code
- Use a local Mina blockchain to interact with your smart contract.

Later tutorials introduce more concepts and patterns.  

The full source code for [01-hello-world](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/01-hello-world) is provided in the codebase `examples`. 

## Setup

First, install the [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) if you haven't already.

### Dependencies

To use the zkApp CLI, your environment requires:

- NodeJS v16 and later (or NodeJS v14 using `--experimental-wasm-threads`)
- NPM v6 and later
- Git v2 and later

Use a package manager to install the required versions and upgrade older versions if needed. Package managers for the supported environments are:

- MacOS [Homebrew](https://brew.sh/)
- Windows [Chocolatey](https://chocolatey.org/)
- Linux

  - apt, yum, and others

  On Linux, you might need to install a recent NodeJS version by using NodeSource. Use [deb](https://github.com/nodesource/distributions#debinstall) or [rpm](https://github.com/nodesource/distributions#rpminstall) as recommended by the NodeJS project.

To verify your installed versions, use `npm -v`, `node -v`, and `git -v`.

### Install the zkApp CLI

To install the zkApp CLI:

```sh
$ npm install -g zkapp-cli
```

To confirm successful installion:

```sh
$ zk --version
```

This tutorial has been tested with Mina zkApp CLI version `0.7.5` and SnarkyJS `0.8.0`.

## Create a new project

Now that you have the tooling installed, you can start building your application.

1. Create or change to a directory where you have write priveleges.
1. Now, create a project using the `zk project` command:

  ```sh
  $ zk project 01-hello-world
  ```

  This command creates the `01-hello-world` directory that contains the scaffolding for your project, including tools such as the Prettier code formatting tool, the ESLint static code analysis tool, and the Jest JavaScript testing framework.

1. The `zk project` command has the ability to scaffold the UI for your project. For this tutorial, select `none`:

  ```
  ? Create an accompanying UI project too? …
    next
    svelte
    nuxt
    empty
  ❯ none
  ```

1. Change into the `01-hello-world` directory and list the contents:

  ```sh
  $ cd 01-hello-world
  $ ls
  ```

  The output shows these results:

  ```sh
  LICENSE
  README.md
  babel.config.cjs
  build
  config.json
  jest-resolver.cjs
  jest.config.js
  keys
  node_modules
  package-lock.json
  package.json
  src
  tsconfig.json
  ```

For this tutorial, you work mostly in the `src` directory that contains the TypeScript code for the smart contract. Each time you make updates, then build or deploy, the TypeScript code is compiled into JavaScript in the `build` directory.

### Preparing the project

Start by deleting the default files that come with the new project.

1. To delete the old files:

  ```sh
  $ rm src/Add.ts
  $ rm src/Add.test.ts
  $ rm src/interact.ts
  ```

1. Now, generate the new files for your project:

  ```sh
  $ zk file src/Square
  $ touch src/main.ts
  ```

The `zk file` command created the `src/Square.ts` and `src/Square.test.ts` test files. However, this tutorial does not include writing tests. Instead, you use `main.ts` as a script to interact with the smart contract and observe how it works. 

In later tutorials, you learn how to interact with a smart contract from the browser, like a typical end user. For this first tutorial, you just use the `main.ts` script.

3. Now, open `src/index.ts` in a text editor and change it to look like:

  ```ts src/index.ts
  1 import { Square } from './Square.js';
  2
  3 export { Square };
  ```

  The `src/index.ts` file contains all of the exports you want to make available for consumption from outside our smart contract project, such as from a UI.

### Building and running

:::info

The following commands are included for reference and will fail if you run them now. This is expected behavior because you haven't written the `Square` smart contract yet.

:::

To compile the TypeScript code into JavaScript and run the JavaScript code:

```
$ npm run build
$ node build/src/main.js
```

Because you haven't built the smart contract yet, this command fails as expected. When successful, the first command creates JavaScript code in the `build` directory. The second command runs the code in `src/main.ts`.

You can also combine these commands together into one line:

```
npm run build && node build/src/main.js
```

After you create a working smart contract, this command runs `main` if the build is successful. For now, command failure is the expected result.  

## Write the zkApp Smart Contract

Now, the fun part! Write your smart contract, the `src/Square.ts` file. 

Line numbers are provided for convenience. A final version of what you're writing is provided in the [Square.tx](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/01-hello-world/src/Square.ts) example file.

:::tip

This tutorial walks through the `Square` smart contract code in the `src/Square.ts` as viewed in a text editor. If this is your first project, use the provided example file for the best user experience.  

:::

## Copy the example 

The easiest way to walk through the example is to use the entire contents in the provided [Square.tx](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/01-hello-world/src/Square.ts) example file. You can then follow the tutorial with the finished code in place.

Or you can follow the steps to copy and paste the code snippets into your project as you go. To avoid inserting the line numbers into your smart contract, use the copy code to clipboard button that appears at the top right of the snippet box when you hover over it.


### Imports

First, open `src/Square.ts` in your editor.

- If you already copied the contents of the example file, then review these lines. 

- If you are adding the code as you go, add the following code at the top of the file.

```ts src/Square.ts
1 import {
2   Field,
3   SmartContract,
4   state,
5   State,
6   method,
7 } from 'snarkyjs';
```

These fields are:

- `Field`: The native number type in SnarkyJS. You can think of Fields as unsigned integers. Fields are the most basic type in SnarkyJS and are what all other SnarkyJS-compatible types are built on top of.
- `SmartContract`: The class that creates zkApp smart contracts.
- `state`: a convenience decorator used within zkApp smart contracts to create references to state stored on-chain in a zkApp account.
- `State`: a class used within zkApp smart contracts to create state stored on-chain in a zkApp account.
- `method`: a convenience decorator used within zkApp smart contracts to create new smart contract methods like functions. Methods that uses this decorator are the end user's entry points to interacting with a smart contract.

### Smart contract class

Now, write the smart contract. 

To create a new smart contract called `Square` with one element of on-chain state named `num` of type `Field`, add the following code to your file:

```ts src/Square.ts
8
9 export class Square extends SmartContract {
10   @state(Field) num = State<Field>();
11
12 }
```

zkApps can have up to eight Fields of on-chain state. Each field stores up to 32 bytes (technically, 31.875 bytes or 255 bit) of arbitrary data. A later tutorial covers options for off-chain state.

Now, add the `init` method:

```ts src/Square.ts
8
9 export class Square extends SmartContract {
10   @state(Field) num = State<Field>();
11
12   init() {
13     super.init();
14     this.num.set(Field(3));
15   }
16
17 }
```

This method sets up the initial state of the smart contract on deployment.

Since you're extending `SmartContract` that has its own initialization to perform, you also need to call `super.init()` to invoke this function on the base class.

Then initialize the on-chain state, `num`, to a value of `3`.

You can optionally [specify permissions](/zkapps/snarkyjs-reference/classes/SmartContract#setpermissions).

Finally, add the update function:

```ts src/Square.ts
14     this.num.set(Field(3));
15   }
16
17   @method update(square: Field) {
18     const currentState = this.num.get();
19     this.num.assertEquals(currentState);
20     square.assertEquals(currentState.mul(currentState));
21     this.num.set(square);
22   }
23 }
```

The name `update` is arbitrary, but it makes sense for this example. Notice that you use the `@method` decorator because this method is intended to be invoked by end users by using a zkApp UI, or as in this case, the `main.ts` script.

This method contain the logic by which end users are allowed to update our the zkApp's account state on chain. In this example, you are saying that if the user provides a number (for example, 9) to the `update()` method that is the square of the existing on-chain state referred to as `num` (for example, 3), then update the `num` value that is stored on-chain to the provided value (in this case, 9). If the user provides a number that does not meet these conditions, they are unable to generate a proof or update the on-chain state.

These update conditions are accomplished by using "assertions" within the method. When a user invokes a method on a smart contract, all assertions must be true in order to generate the zero knowledge proof from that smart contract. The Mina network accepts the transaction and updates the on-chain state only if the attached proof is valid. This assertion is how to achieve predictable behavior in an off-chain execution model.

Notice that you have `get()` and `set()` methods for retrieving and setting on-chain state. 

- A smart contract retrieves the on-chain account state when it is first invoked if at least one `get()` exists within it. 

- Similarly, using `set()` changes the transaction to indicate that changes to this particular on-chain state are updated only when the transaction is received by the Mina network if it contains a valid authorization (usually, a valid authorization is a proof).

The logic also uses the `.mul()` method for multiplication of the values stored in `Field` types. You can view all available methods in the [SnarkyJS reference](/zkapps/snarkyjs-reference) documentation. 

:::info

All functions used inside your smart contract must operate on SnarkyJS compatible data types: `Field` types and other types built on top of `Field` types. 

:::info

Functions from random NPM packages won't work inside a smart contract, because it's really a zero-knowledge circuit, unless the functions it provides operate on SnarkyJS-compatible data types.

**Importantly, data passed as an input to a smart contract method in SnarkyJS is private and never seen by the network.** 

You can also store data publicly on-chain when needed, the the `num` in this example. A later tutorial covers an example that leverages privacy.

This completes the smart contract!

## Interacting with our smart contract

Next, we will write a script that interacts with our smart contract, so we can easily test it out, for purposes of this tutorial.

Open up `src/main.ts` in your editor. A complete version of this file can be found [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/01-hello-world/src/main.ts). Again, we recommend that you copy this whole file over to begin with, and then work through the tutorial steps with the complete file in place.

### Imports

Add the following:

```ts src/main.ts
1 import { Square } from './Square.js';
2 import {
3   isReady,
4   shutdown,
5   Field,
6   Mina,
7   PrivateKey,
8   AccountUpdate,
9 } from 'snarkyjs';
10
```

What each of these imports are:

- `isReady`: an asynchronous promise that tells us when SnarkyJS is loaded and ready. This is necessary because SnarkyJS contains WASM.
- `shutdown`: a function that closes our program.
- `Field`: SnarkyJS' unsigned integer type, that we've seen above.
- `Mina`: A local Mina blockchain. We will deploy our smart contract to this in order to interact with it as a user would.
- `PrivateKey`: a class with functions for manipulating private keys.
- `AccountUpdate`: a class that generates a data structure referred to as an AccountUpdate that can update zkApp accounts.

### Local Blockchain

Now add the following code to your `src/main.ts`:

```ts src/main.ts
11 await isReady;
12
13 console.log('SnarkyJS loaded')
14
15 const useProof = false;
16
17 const Local = Mina.LocalBlockchain({ proofsEnabled: useProof });
18 Mina.setActiveInstance(Local);
19 const { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];
20 const { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];
21
22 console.log('Shutting down')
23
24 await shutdown();
```

Now when you run

```sh
$ npm run build && node build/src/main.js
```

your main function should run!

In production, you'll [deploy your zkApp to Mina network](https://docs.minaprotocol.com/zkapps/how-to-deploy-a-zkapp). But this "local blockchain" allows us to speed up development and test the behavior of our smart contract locally. This local blockchain also provides pre-funded accounts (e.g. the `deployerAccount` above). Later tutorials will discuss how to deploy your zkApp to live Mina networks, such as Berkeley Testnet.

:::note

zkApp programmability is currently available on Berkeley Testnet, Mina's public testnet, which is in its final stages of testing before Mainnet.

:::

### Initializing our smart contract

Now, let's expand the `main.ts` file to initialize our smart contract. Comments are provided to break down each stage.

```ts src/main.ts
19 const { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];
20 const { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];
21
22 // ----------------------------------------------------
23
24 // Create a public/private key pair. The public key is our address and where we will deploy to
25 const zkAppPrivateKey = PrivateKey.random();
26 const zkAppAddress = zkAppPrivateKey.toPublicKey();
27
28 // create an instance of Square - and deploy it to zkAppAddress
29 const zkAppInstance = new Square(zkAppAddress);
30 const deployTxn = await Mina.transaction(deployerAccount, () => {
31   AccountUpdate.fundNewAccount(deployerAccount);
32   zkAppInstance.deploy();
33 });
34 await deployTxn.sign([deployerKey, zkAppPrivateKey]).send();
35
36 // get the initial state of Square after deployment
37 const num0 = zkAppInstance.num.get();
38 console.log('state after init:', num0.toString());
39
40 // ----------------------------------------------------
41
42 console.log('Shutting down')
43
44 await shutdown();
```

The above code will be similar for any smart contract that you create.

Try running this now with: `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
Shutting down
```

### Updating our zkApp account with a transaction

Now let's try updating our local zkApp account with a transaction! Add the following:

```ts src/main.ts
38 console.log('state after init:', num0.toString());
39
40 // ----------------------------------------------------
41
42 const txn1 = await Mina.transaction(senderAccount, () => {
43   zkAppInstance.update(Field(9));
44 });
45 await txn1.prove();
46 await txn1.sign([senderKey]).send();
47
48 const num1 = zkAppInstance.num.get();
49 console.log('state after txn1:', num1.toString());
50
51 // ----------------------------------------------------
52
53 console.log('Shutting down')
54
55 await shutdown();
```

This code creates a new transaction that attempts to update the field to the value `9`. Because this follows the rules in the `update()` function that we are calling on the smart contract, this should pass. And if you run it, it should!

Use `npm run build && node build/src/main.js` again to run it:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
Shutting down
```

Now let's try adding a transaction that should fail - updating the state to `75`. Now that `num` is in state `9`, updating should only be possible with `81`.

```ts src/main.ts
49 console.log('state after txn1:', num1.toString());
50
51 // ----------------------------------------------------
52
53 try {
54   const txn2 = await Mina.transaction(senderAccount, () => {
55     zkAppInstance.update(Field(75));
56   });
57   await txn2.prove();
58   await txn2.sign([senderKey]).send();
59 } catch (ex: any) {
60   console.log(ex.message);
61 }
62 const num2 = zkAppInstance.num.get();
63 console.log('state after txn2:', num2.toString());
64
65 // ----------------------------------------------------
66
67 console.log('Shutting down')
68
69 await shutdown();
```

Run this again with `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 75 != 81
state after txn2: 9
Shutting down
```

And lastly, to show the correct update:

```ts src/main.ts
63 console.log('state after txn2:', num2.toString());
64
65 // ----------------------------------------------------
66
67 const txn3 = await Mina.transaction(senderAccount, () => {
68   zkAppInstance.update(Field(81));
69 });
70 await txn3.prove();
71 await txn3.sign([senderKey]).send();
72
73 const num3 = zkAppInstance.num.get();
74 console.log('state after txn3:', num3.toString());
75
76 // ----------------------------------------------------
77
78 console.log('Shutting down');
79
80 await shutdown();
```

Run this again with `npm run build && node build/src/main.js`. The output should be:

```sh
$ npm run build && node build/src/main.js
...
SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 75 != 81
state after txn2: 9
state after txn3: 81
Shutting down
```

## Conclusion

Congrats! We have finished building our first zkApp with SnarkyJS.

Checkout [Tutorial 2](private-inputs-hash-functions) to learn how to use private inputs and hash functions with SnarkyJS.

Then you can go further by reading the [zkApps docs](/zkapps) and additional tutorials.
