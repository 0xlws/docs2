---
title: 'Tutorial 6: Off-Chain Storage'
hide_title: true
sidebar_label: 'Tutorial 6: Off-Chain Storage'
description: Learn options for zkApps that require trustless solutions in this implementation of a single-server off-chain storage solution.
keywords:
  - smart contracts
  - zkapps
  - off-chain storage
  - smart contract
  - trustless zero knowledge
  - off-chain storage
  - zk proof
  - zk
  - blockchain
  - mina
---

:::info

zkApp programmability is not yet available on the Mina Mainnet. You can get started now by deploying zkApps to the Berkeley Testnet.

:::

# Tutorial 6: Off-Chain Storage

In [Tutorial 5: Common Types and Functions](common-types-and-functions), you learned how to use Merkle trees to refer to large amounts of data stored off-chain.

This tutorial presents a library and pattern to store Merkle trees off-chain and store only the tree's root hash on-chain. 

This approach is a step towards unlocking a larger set of applications that require off-chain storage. Future solutions can provide more decentralized options for zkApps that require more trustless solutions.

This tutorial provides a single-server solution to data storage for prototyping zkApps and building zkApps where some trust guarantees are reasonable. The solution proposed in this learning tutorial is appropriate for development, but is not recommended for zkApps that require trustlessness. 

The single-server solution for prototyping is intended as one of several options for data availability on Mina. Mina doesn't offer an out-of-the-box solution for off-chain storage. 

Mina Foundation values contributions. A [Grant Opportunity to Develop Single-Server Off-Chain Storage](#grant-opportunity-to-develop-single-server-off-chain-storage) is available to improve this library to make it more decentralized and useful in production.

## Why Off-Chain Storage?

When you build an application for testing and local use, you can build and store a Merkle root locally.

However, when you build a production-ready, distributed zkApp, you need more than this. All users that interact with your zkApp must be able to retrieve and modify the latest state.

Any data that modifies a zkApp must be available somewhere for others users to access.

### Off-Chain Storage and Decentralization

Solutions to storage span a large spectrum from inexpensive and more centralized to more expensive and more decentralized. The decentralized solutions are more expensive due to replicating and proving stored data.

Your off-chain storage needs depend on the zkApp you are building and the guarantees you want that zkApp to have.

Solutions under exploration:

1. A single-server storage solution, presented here.
2. A multi-server storage solution that can be run by multiple parties for stronger trust guarantees.
3. A solution that leverages storage on modular blockchains.
4. A future hard fork to add purchasable on-chain data storage to Mina.
5. A future hard fork to add data-storage committees to Mina for horizontally scalable storage.

### Single-Server Off-Chain Storage

This tutorial implementation is the single-server off-chain storage solution. The library provides a REST server that anyone can run to store data for one or multiple zkApps and a zkApp library to check on-chain if changes have been backed by the server.

This implementation requires a trust assumption for zkApps that use it: both developers and users must trust whoever is running the server.

This trust assumption makes it useful for prototyping applications that need off-chain storage and putting applications into production where these trust assumptions are reasonable. This implementation is not appropriate for zkApps where a trustless solution is needed.

See the [zkApp-offchain-storage](https://github.com/es92/zkApp-offchain-storage) library to learn more about this implementation and see how it works.

### Grant Opportunity to Develop Single-Server Off-Chain Storage

This development opportunity seeks a developer to start with the library presented here, improve it, make it more decentralized, and run instances for the community. If interested in this grant opportunity, send an email to [build@minaprotocol.com](mailto:build@minaprotocol.com).

Suggested improvements:

- Eliminate DDOS vulnerability by adding a token that limits storage requests.
- Do not store trees for a smart contract if that contract is misconfigured in a way to prevent cleaning up old data.
- Add support to the client library for connecting to multiple storage servers, enabling correctness under a majority-honest assumption.
- Switch the project to a more scalable database implementation (e.g. Redis).
- Write an implementation for an automatically scalable service (e.g. Cloudflare).

## Implement a Project Using Off-Chain Storage

The sample code for this project is provided at [examples/zkapps/06-offchain-storage/contracts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts) with a focus on:

- [src/main.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts)
- [src/NumberTreeContract.ts](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/NumberTreeContract.ts) 

This project implements a Merkle tree where:

- Each leaf is either empty or stores a number, which is the data. 
- Updates to the tree can update a leaf if the new number in the leaf is greater than the old number. 
- The root of the tree is stored on-chain. 
- The tree itself is stored on an off-chain storage server.

## Prerequisites

This tutorial has been verified with [zkApp CLI](https://github.com/o1-labs/zkapp-cli) version `0.11.0` and [SnarkyJS](https://www.npmjs.com/package/snarkyjs) `0.12.1`.

Ensure your environment meets the [Prerequisites](/zkapps/tutorials#prerequisites) for zkApp Developer Tutorials.

## Project Setup

1. Create or change to a directory where you have write privileges.
2. Create a project by using the `zk project` command:

  ```sh
  $ zk project 06-off-chain-storage
  ```

  The `zk project` command has the ability to scaffold the UI for your project. For this tutorial, select `none`:

  ```
  ? Create an accompanying UI project too? …
    next
    svelte
    nuxt
    empty
  ❯ none
  ```

  The `zk project` command creates the `06-off-chain-storage` directory that contains the scaffolding for your project.

1. Change to the project directory, delete the existing files, and create a new smart contract and a main file:

  ```sh
  $ cd 06-off-chain-storage
  $ rm src/Add.ts
  $ rm src/Add.test.ts
  $ rm src/interact.ts
  $ zk file src/NumberTreeContract
  $ touch src/main.ts
  ```

1. Edit `index.ts` to import and export your new smart contract:

  ```ts
  import { NumberTreeContract } from './NumberTreeContract.js';

  export { NumberTreeContract };
  ```

1. Now, add the library for the off-chain storage server:

  ```sh
  $ npm install experimental-zkapp-offchain-storage --save
  ```

1. Install the `xmlhttprequest-ts` TypeScript wrapper for the built-in HttpClient to emulate the browser XMLHttpRequest object:

  ```sh
  $ npm install --save xmlhttprequest-ts
  ```

  This project uses this for network requests when running from Node.js where the browser's XMLHttpRequest is not available by default.


With that, setup is complete!

### Add code to the project

As in previous tutorials, you run `main.ts` with:

```sh
$ npm run build && node build/src/main.js
```

The expected result is for the command to fail because the new project is not valid until you add code to `main.ts` and `NumberTreeContract.ts`. 

### Run your storage server

To start a storage server and create a `database.json` file in the current directory to store data for this tutorial, start the storage server from the root directory of your project.

In a new terminal window:

```sh
$ cd 06-off-chain-storage
$ node node_modules/experimental-zkapp-offchain-storage/build/src/storageServer.js
```

## Implementing the Smart Contract

To start, open `NumberTreeContract.ts` in your editor. You can find a full copy of this file [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/05-common-types-and-functions/src) for reference.

Start by adding our imports:

```ts
  1 import {
  2   SmartContract,
  3   Field,
  4   MerkleTree,
  5   state,
  6   State,
  7   method,
  8   DeployArgs,
  9   Signature,
 10   PublicKey,
 11   Permissions,
 12   Bool,
 13 } from 'snarkyjs';
 14
 15 import {
 16   OffChainStorage,
 17   Update,
 18   MerkleWitness8,
 19 } from 'experimental-zkapp-offchain-storage';
...
```

Notice we import some items from `zkapp-offchain-storage`:

- `OffChainStorage` is object containing functions for interacting with off-chain storage. These are:
  - `getPublicKey`: A function to get the storage server's public key. This is also stored in smart contracts to identify what storage server is storing the smart contract's off-chain data.
  - `get`: A function for fetching the data for a merkle tree from the storage server, given the root of the tree.
  - `requestStore`: A function to request storing a tree on the storage server. Returns a proof that the storage server has stored this tree.
  - `assertRootUpdateValid`: A function used in smart contracts, to prove updates to the smart contract's currently stored tree root result in a tree root that is being stored by the storage server.
  - `mapToTree`: A storage function to convert maps to trees. Internally the storage server is using maps from tree indices to leafs.
- `Update`: A type for updates to merkle trees. We'll be using this below in the smart contract.
- `MerkleWitness8`: The type of our merkle tree witness. Others are available for input, such as `MerkleWitness32` and `MerkleWitness256`. This is necessary for SnarkyJS to use the same instances of the witness cross-library.

Continuing, let's setup our smart contract:

```ts
...
 21 export class NumberTreeContract extends SmartContract {
 22   @state(PublicKey) storageServerPublicKey = State<PublicKey>();
 23   @state(Field) storageNumber = State<Field>();
 24   @state(Field) storageTreeRoot = State<Field>();
 25
 26
 27
 28   deploy(args: DeployArgs) {
 29     super.deploy(args);
 30     this.account.permissions.set({
 31       ...Permissions.default(),
 32       editState: Permissions.proofOrSignature(),
 33     });
 34   }
 35
 36   @method initState(storageServerPublicKey: PublicKey) {
 37     this.storageServerPublicKey.set(storageServerPublicKey);
 38     this.storageNumber.set(Field(0));
 39
 40     const emptyTreeRoot = new MerkleTree(8).getRoot();
 41     this.storageTreeRoot.set(emptyTreeRoot);
 42   }
...
```

Here we add 3 pieces of state to our contract: the public key of the storage server, the "storageNumber"—which is used to ensure the storage server is actively storing states, and the root of the merkle tree.

We also initialize our zkApp's state for these three values, by setting them to the public key of our storage server, setting storage number to 0, and storing the root of an empty tree.

Continuing, here is our update function:

```ts
...
 42   @method update(
 43     leafIsEmpty: Bool,
 44     oldNum: Field,
 45     num: Field,
 46     path: MerkleWitness8,
 47     storedNewRootNumber: Field,
 48     storedNewRootSignature: Signature
 49   ) {
 50     const storedRoot = this.storageTreeRoot.get();
 51     this.storageTreeRoot.assertEquals(storedRoot);
 52
 53     let storedNumber = this.storageNumber.get();
 54     this.storageNumber.assertEquals(storedNumber);
 55
 56     let storageServerPublicKey = this.storageServerPublicKey.get();
 57     this.storageServerPublicKey.assertEquals(storageServerPublicKey);
 58
 59     let leaf = [oldNum];
 60     let newLeaf = [num];
 61
 62     // newLeaf can be a function of the existing leaf
 63     newLeaf[0].assertGt(leaf[0]);
 64
 65     const updates = [
 66       {
 67         leaf,
 68         leafIsEmpty,
 69         newLeaf,
 70         newLeafIsEmpty: Bool(false),
 71         leafWitness: path,
 72       },
 73     ];
 74
 75     const storedNewRoot = OffChainStorage.assertRootUpdateValid(
 76       storageServerPublicKey,
 77       storedNumber,
 78       storedRoot,
 79       updates,
 80       storedNewRootNumber,
 81       storedNewRootSignature
 82     );
 83
 84     this.storageTreeRoot.set(storedNewRoot);
 85     this.storageNumber.set(storedNewRootNumber);
 86   }
 87 }
```

We get and assert the current state of the contract - and then we perform the update.

First, we check that the new leaf is greater than the old leaf.

Then, we check the update itself. In this example, we perform a single update to the tree, however with multiple witnesses, you can chain updates together to change the tree more than once in a single call to the storage server.

To assert the update is valid, we use a `assertRootUpdateValid` call from the `OffChainStorage` library. This checks that when the update is applied to the tree represented by the existing on-chain tree root, the data for the new tree is being stored by the storage server.

That completes the smart contract!

## Implementing `main.ts`

You can find a full copy of this file [here](https://github.com/o1-labs/docs2/blob/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts) for reference.

We will not be implementing this full file, instead just discussing a few parts of it, since much is repeated from earlier tutorials. So download it from the above link, place it in your src folder, and then open it in your editor.

Note that it contains logic for both running the contract locally and for deploying and interacting with it on Berkeley. This is a useful pattern when developing a new contract. If you would like to try it on Berkeley, deploy our contract as usual with `zk deploy`, set `useLocal` to false in `main.ts`, and add the name of your config to the end of your call to `node main.js`.

To start, we will connect to the off-chain storage server:

```ts
...
 73   const storageServerAddress = 'http://localhost:3001';
 74   const serverPublicKey = await OffChainStorage.getPublicKey(
 75     storageServerAddress,
 76     NodeXMLHttpRequest
 77   );
...
```

Here, we connect to the storage server, and get its public key. Running the storage server as described above starts it by default on port 3001, and so this code is configured to connect to it there. In a real application, you would run the storage server on an externally exposed machine, and change this address from localhost to match.

Next we will describe the `updateTree` function, starting on line `120`.

Our goal in this function is to:

1. Get the currently stored tree from the storage server
2. Select a random leaf
3. Change the value at that leaf to a bigger number
4. Create a transaction that performs this update.

To start, let's get the existing tree:

```ts
...
109   async function updateTree() {
110     const index = BigInt(Math.floor(Math.random() * 4));
111
112     // get the existing tree
113     const treeRoot = await zkapp.storageTreeRoot.get();
114     const idx2fields = await OffChainStorage.get(
115       storageServerAddress,
116       zkappPublicKey,
117       treeHeight,
118       treeRoot,
119       NodeXMLHttpRequest
120     );
121
122     const tree = OffChainStorage.mapToTree(treeHeight, idx2fields);
123     const leafWitness = new MerkleWitness8(tree.getWitness(index));
...
```

Here, we get the current root stored in the contract - and request the data for that root from the storage server.

Then, we convert that data from a map to a MerkleTree - and we get a witness for a random index of the merkle tree.

Continuing:

```ts
...
125     // get the prior leaf
126     const priorLeafIsEmpty = !idx2fields.has(index);
127     let priorLeafNumber: Field;
128     let newLeafNumber: Field;
129     if (!priorLeafIsEmpty) {
130       priorLeafNumber = idx2fields.get(index)![0];
131       newLeafNumber = priorLeafNumber.add(3);
132     } else {
133       priorLeafNumber = Field(0);
134       newLeafNumber = Field(1);
135     }
...
```

Here, we check if the leaf is empty, and shape our update accordingly. If the leaf was empty, we set it to one. Otherwise, we set the leaf to whatever used to be there, plus 3.

```ts
...
140     const [storedNewStorageNumber, storedNewStorageSignature] =
141       await OffChainStorage.requestStore(
142         storageServerAddress,
143         zkappPublicKey,
144         treeHeight,
145         idx2fields,
146         NodeXMLHttpRequest
147       );
...
```

And lastly, we request that the storage server stores our data. If successful, we are returned a new storage number and a signature, which we will use for updating the smart contract.

We call our smart contract as follows:

```ts
...
160     const doUpdate = () => {
161       zkapp.update(
162         Bool(priorLeafIsEmpty),
163         priorLeafNumber,
164         newLeafNumber,
165         leafWitness,
166         storedNewStorageNumber,
167         storedNewStorageSignature
168       );
169     }
170
171     if (useLocal) {
172       const updateTransaction = await Mina.transaction(
173         { sender: feePayerKey.toPublicKey(), fee: transactionFee },
174         () => {
175           doUpdate();
176         }
177       );
178
179       updateTransaction.sign([zkappPrivateKey, feePayerKey])
180       await updateTransaction.prove();
181       await updateTransaction.send();
...
```

That completes our review of the code to interact with the off-chain storage server! As mentioned previously, you can find the full copy of this file [here](https://github.com/o1-labs/docs2/tree/main/examples/zkapps/06-offchain-storage/contracts/src/main.ts) for review.

## Conclusion

Congrats! We have finished building a smart contract that leverages off-chain storage

Checkout [Tutorial 7](oracle) to learn how to use Oracles, to pull in data from the outside world into your zkApp.
