---
title: 'Tutorial 7: Oracles'
hide_title: true
sidebar_label: 'Tutorial 7: Oracles'
description: Use an oracle when your smart contract needs to consume data from the outside world.
keywords:
  - smart contracts
  - zkapps
  - oracles
  - zero knowledge proof programming
  - zk proof
  - zk
  - blockchain
  - mina
---

import ResponsiveVideo from '@site/src/components/common/ResponsiveVideo';

:::info

zkApp programmability is not yet available on the Mina Mainnet. You can get started now by deploying zkApps to the Berkeley Testnet.

:::

# Tutorial 7: Oracles

You can use an oracle when your smart contract needs to consume data from the outside world.

Learn about zkOracles in this 5-minute video:

<ResponsiveVideo src="https://www.youtube.com/embed/lvX_l9tb_rQ" />

## Prerequisites

- Make sure you have the zkApp CLI installed:

    ```sh
    $ npm install -g zkapp-cli
    ```

- Ensure your environment meets the [Prerequisites](/zkapps/tutorials#prerequisites) for zkApp Developer Tutorials.

This tutorial has been tested with:

- [Mina zkApp CLI](https://github.com/o1-labs/zkapp-cli) version 0.11.2
- [o1js](https://www.npmjs.com/package/o1js) version 0.12.1

## High-Level Overview

In this tutorial, you build an oracle that retrieves data from a REST API and write a smart contract that consumes information from this oracle.

1. Retrieve data from a REST API that provides mock credit score information for two users: one with a high credit score and one with a low credit score. 
1. The smart contract consumes this information and allows users to prove their credit score is above a certain threshold (for example, higher than 700).

Using the smart contract, an end user can generate an attestation that their credit score is above a certain value. To maintain their privacy, the user can prove this fact to a third party without sharing the exact credit score or other personal information.

This tutorial uses a mock credit score API as the data source and provides a foundation to create an oracle for any type of data. Just swap out the oracle's HTTP request to use any REST API or GraphQL API source.  

## How Oracles Work

Oracles connect blockchain smart contracts with the outside world
to get data on chain. 

Mina smart contracts run off-chain and make it possible to prove that the expected computation was run on private data without revealing the data itself. When the smart contract consumes data from a third-party source, you want to verify that this data is authentic and was provided by the expected source.

Mina zkOracles do not allow a zkApp to consume data trustlessly from any HTTPS data source. The oracle design described in this tutorial is typically operated by the zkApp developer. The oracle fetches and signs the desired data, then a zkApp can consume this data and verify the signature to ensure that the data was provided by the expected source.

Data providers can also operate response signers like the one described to provide users with an oracle that does not require them to trust an intermediary. In other words, if a credit score or other data provider chooses to sign response data themselves, users can consume data from that source without trusting anybody besides the data provider they already trust to provide correct data.

### Design

The simple oracle design:

- Fetches data from the desired source
- Signs it using a Mina-compatible private key
- Returns the data, signature, and public key associated with the private key
- Allows the signature to be verified by the zkApp

### Code

The full source code for this tutorial is provided in [Jack's external repo](https://github.com/jackryanservia/mina-credit-score-signer/blob/main/index.js).

To generate a Mina-compatible public/private key pair for your oracle, run:

```sh
npm run keygen
```

This command runs the script in the [keygen.js](https://github.com/jackryanservia/mina-credit-score-signer/blob/main/scripts/keygen.js) file.

This oracle uses a Koa server hosted on DigitalOcean. It's short, but you don't have to dive into the code now. The code is commented to explain each step so you can build something similar for yourself.

You can adapt this code to create oracles for other API sources. For example, if you want your smart contract to ingest price feed data from an exchange, query the exchange API, sign the results, and return a response in the following response format.

### Response Format

The oracle returns its response in JSON with three, top-level properties:

- `data` is an object of the information you are interested in and can have any form.
- `signature` is a signature for the `data` created using the oracle operator's private key. Smart contracts use this signature to verify that data was provided by the expected source.
- `publicKey` is the public key of the oracle is the same for all requests to this oracle.

The following example is a response from the oracle for the user with an `id` of `1`. In the real world, this `id` might be a social security number or a similar identifier. Notice that the data property contains their credit score and user id.

```json
{
  "data": { "id": "1", "creditScore": "787" },
  "signature": {
    "r": "6879645159505819706680368079573694250155734132188077159564484773379936889926",
    "s": "25770716061409035848137554965765890473013735453379104563619678415983125445906"
  },
  "publicKey": "B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy"
}
```

This demo oracle also provides a response for a user id of `2` who has a credit score that is below the threshold specified in the smart contract.

```json
{
  "data": { "id": "2", "creditScore": "536" },
  "signature": {
    "r": "17330964553212655684849406067090021752962217822408913431446690101683066224611",
    "s": "26366190712354094401916556126787229546643001327044048354949322240615669643867"
  },
  "publicKey": "B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy"
}
```

While the first user has a credit score of `787`, the second user only has a credit score of `536`. The `signature` is also changed. This makes sense because the payload is different from what is received in the first response. Finally, notice that the `publicKey` is the same because in each case we are querying data from the same provider.

For purposes of this tutorial, you can access the demo oracle at https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/1 and https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/2, if you don't want to set up your own oracle right now.

## Smart Contract

Now that you have an oracle that returns signed data, you can write a smart contract that uses this data.

### Create a project

1. Create or change to a directory where you have write privileges.

1. Create a project by using the `zk project` command:

  ```sh
  $ zk project 07-oracles
  ```

  The `zk project` command has the ability to scaffold the UI for your project. For this tutorial, select `none`:

  ```text
  ? Create an accompanying UI project too? …
    next
    svelte
    nuxt
    empty
  ❯ none
  ```
1. Change into the `07-oracles` directory.

For this tutorial, you run commands from the root of the `07-oracles` directory as you work in the `src` directory on files that contain the TypeScript code for the smart contract. 

Each time you make updates, then build or deploy, the TypeScript code is compiled into JavaScript in the `build` directory.


## Prepare the project

Delete the default generated files by running:

```sh
$ rm src/Add.ts
$ rm src/Add.test.ts
$ rm src/interact.ts
```

And create new files:

```sh
$ zk file CreditScoreOracle
```

And lastly, change `index.ts` to:

```ts
import { CreditScoreOracle } from './CreditScoreOracle.js';

export { CreditScoreOracle };
```

### Writing our Smart Contract

Open up `/src/CreditScoreOracle.ts` and paste in the following:

<!-- prettier-ignore -->
```ts
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  DeployArgs,
  Permissions,
  PublicKey,
  Signature,
  PrivateKey,
} from 'o1js';

// The public key of our trusted data provider
const ORACLE_PUBLIC_KEY =
  'B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy';

export class OracleExample extends SmartContract {
  // Define contract state

  // Define contract events

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
    });
  }

  @method init(zkappKey: PrivateKey) {
    super.init(zkappKey);
    // Initialize contract state

    // Specify that caller should include signature with tx instead of proof
    this.requireSignature();
  }

  @method verify(id: Field, creditScore: Field, signature: Signature) {
    // Get the oracle public key from the contract state

    // Evaluate whether the signature is valid for the provided data

    // Check that the signature is valid

    // Check that the provided credit score is greater than 700

    // Emit an event containing the verified users id

  }
}
```

This just adds the basic setup for our smart contract. For more details on the `deploy()` method — see [Tutorial 1: Hello World](hello-world).

## On-Chain State

Our smart contract will store the public key for the oracle that we choose to retrieve data from as on-chain state so that it is available when end users run the smart contract. The smart contract will then use this to verify the signature of the data to confirm it came from the expected source.

```ts
  // Define contract state
  @state(PublicKey) oraclePublicKey = State<PublicKey>();
```

We’ll use the `init` method to initialize `oraclePublicKey` to the credit score oracle’s public key.

```ts
  @method init(zkappKey: PrivateKey) {
    super.init(zkappKey);
    // Initialize contract state
    this.oraclePublicKey.set(PublicKey.fromBase58(ORACLE_PUBLIC_KEY));
    // Specify that caller should include signature with tx instead of proof
    this.requireSignature();
  }
```

`init` is a method that the contract developer can run after the contract is deployed, but before users have the chance to interact with it, to set the initial on-chain state and other configuration. You can think of it like a constructor in a Solidity contract.

## Emitting Events

Our smart contract will check that a user has a credit score above a certain threshold, but how can we expose the result to the outside world? We can emit events! Events allow smart contracts to publish arbitrary messages that anybody can verify without requiring that we store them in the state of a zkApp account. This property makes them ideal for communication with other parts of your application that don’t live on-chain (like your UI, or even an external service).

Let’s add an `events` object to our Smart Contract class to define the names and types of the events it will emit.

```ts
// Define contract events
events = {
  verified: Field,
};
```

## Defining our `verify()` Method

Now, let’s add a method to verify a user’s credit score is above 700.

This is defined the same as any other TypeScript method, except that it must have the `@method` decorator in front of it, which tells o1js that this method can be invoked by users when they interact with the smart contract.

```ts
  @method verify(id: Field, creditScore: Field, signature: Signature) {
```

We will pass in a few arguments.

- `userId`: The id of the users whose credit score we requested. Necessary to prevent bad actors from querying somebody else data and claiming it as their own.
- `creditScore`: The (fake) credit score of the user (a number between 350 and 800).
- `signature`: A cryptographic signature of our `userId` and `creditScore`. This is what our smart contract will use in order to verify that the data was provided by the expected source.

The `verify()` method will not return any values or change any contract state, instead it will emit an `id` event with the user’s id if their credit score is above 700.

### Fetching the Oracle’s Public Key

Now let’s get the oracle’s public key from the on-chain state. We will need this to verify the signature of data from the oracle.

```ts
// Get the oracle public key from the contract state
const oraclePublicKey = this.oraclePublicKey.get();
this.oraclePublicKey.assertEquals(oraclePublicKey);
```

We use `assertEquals()` to ensure that the public key we retrieved at execution time is the same as the public key that exists within the zkApp account on the Mina network when the transaction is processed by the network.

### Verify the Signature

Next, we’ll verify that the signature on the data (`id` and `creditScore`) is valid for the expected public key, to ensure it was from our expected source. This will return true if the signature is valid, and false if it is not.

```ts
// Evaluate whether the signature is valid for the provided data
const validSignature = signature.verify(oraclePublicKey, [id, creditScore]);
```

We also want it to make it impossible to generate a valid zero-knowledge proof if `validSignature` is false. We can do this with `assertTrue()`. If the signature is invalid, this will throw an exception and make it impossible to generate a valid ZKP and transaction.

```ts
// Check that the signature is valid
validSignature.assertTrue();
```

### Check that the Users Credit Score Is Above 700

We want our `verify()` method to only emit an event if the user’s credit score is above 700. We can ensure that this condition is met by calling the `assertGte()` (i.e. assert greater than or equal to) on the `creditScore`.

```ts
// Check that the provided credit score is greater than 700
creditScore.assertGte(Field(700));
```

These assert methods create a constraint that makes it impossible for users to generate a valid zero-knowledge proof unless their condition is met. Without a valid zero-knowledge proof (or a signature) it’s impossible to generate a valid Mina transaction. So, we can now rest assured that users can only call our smart contract method and send a valid transaction if they have a valid signature from our expected oracle and a credit score above 700.

### Emitting our `verified` Event

Now that we are sure everything checks out, we can emit an event to indicate this. The first argument to `emitEvent()` is an arbitrary string name chosen by the developer (because a smart contract could emit more than one type of event) and the second argument can be any value, as long as it matches the type defined for our event earlier. In this case, our event is `Field`, but it could be a more complicated type built on Fields, if the situation called for it. Emitted events are stored and available on archive nodes in the Mina network.

```ts
// Emit an event containing the verified users id
this.emitEvent('verified', id);
```

## Testing it Out

The zkApp CLI automatically generated a file called `CreditScoreOracle.test.ts` for us when we ran `zk file CreditScoreOracle`. Let’s add some tests. Open it and paste in the following:

```ts
import { OracleExample } from './CreditScoreOracle';
import {
  isReady,
  shutdown,
  Field,
  Mina,
  PrivateKey,
  PublicKey,
  AccountUpdate,
  Signature,
} from 'o1js';

// The public key of our trusted data provider
const ORACLE_PUBLIC_KEY =
  'B62qoAE4rBRuTgC42vqvEyUqCGhaZsW58SKVW4Ht8aYqP9UTvxFWBgy';

let proofsEnabled = false;
function createLocalBlockchain() {
  const Local = Mina.LocalBlockchain({ proofsEnabled });
  Mina.setActiveInstance(Local);
  return Local.testAccounts[0].privateKey;
}

async function localDeploy(
  zkAppInstance: OracleExample,
  zkAppPrivatekey: PrivateKey,
  deployerAccount: PrivateKey
) {
  const txn = await Mina.transaction(deployerAccount, () => {
    AccountUpdate.fundNewAccount(deployerAccount);
    zkAppInstance.deploy({ zkappKey: zkAppPrivatekey });
    zkAppInstance.init(zkAppPrivatekey);
  });
  await txn.prove();
  txn.sign([zkAppPrivatekey]);
  await txn.send();
}

describe('CreditScoreOracle', () => {
  let deployerAccount: PrivateKey,
    zkAppAddress: PublicKey,
    zkAppPrivateKey: PrivateKey;

  beforeAll(async () => {
    await isReady;
    if (proofsEnabled) OracleExample.compile();
  });

  beforeEach(async () => {
    deployerAccount = createLocalBlockchain();
    zkAppPrivateKey = PrivateKey.random();
    zkAppAddress = zkAppPrivateKey.toPublicKey();
  });

  afterAll(async () => {
    // `shutdown()` internally calls `process.exit()` which will exit the running Jest process early.
    // Specifying a timeout of 0 is a workaround to defer `shutdown()` until Jest is done running all tests.
    // This should be fixed with https://github.com/MinaProtocol/mina/issues/10943
    setTimeout(shutdown, 0);
  });

  it('generates and deploys the `CreditScoreOracle` smart contract', async () => {
    const zkAppInstance = new OracleExample(zkAppAddress);
    await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);
    const oraclePublicKey = zkAppInstance.oraclePublicKey.get();
    expect(oraclePublicKey).toEqual(PublicKey.fromBase58(ORACLE_PUBLIC_KEY));
  });

  describe('actual API requests', () => {
    it('emits an `id` event containing the users id if their credit score is above 700 and the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const response = await fetch(
        'https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/1'
      );
      const data = await response.json();

      const id = Field(data.data.id);
      const creditScore = Field(data.data.creditScore);
      const signature = Signature.fromJSON(data.signature);

      const txn = await Mina.transaction(deployerAccount, () => {
        zkAppInstance.verify(
          id,
          creditScore,
          signature ?? fail('something is wrong with the signature')
        );
      });
      await txn.prove();
      await txn.send();

      const events = await zkAppInstance.fetchEvents();
      const verifiedEventValue = events[0].event.toFields(null)[0];
      expect(verifiedEventValue).toEqual(id);
    });

    it('throws an error if the credit score is below 700 even if the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const response = await fetch(
        'https://mina-credit-score-signer-pe3eh.ondigitalocean.app/user/2'
      );
      const data = await response.json();

      const id = Field(data.data.id);
      const creditScore = Field(data.data.creditScore);
      const signature = Signature.fromJSON(data.signature);

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });
  });

  describe('hardcoded values', () => {
    it('emits an `id` event containing the users id if their credit score is above 700 and the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(1);
      const creditScore = Field(787);
      const signature = Signature.fromJSON({
        r:
          '13209474117923890467777795933147746532722569254037337512677934549675287266861',
        s:
          '12079365427851031707052269572324263778234360478121821973603368912000793139475',
      });

      const txn = await Mina.transaction(deployerAccount, () => {
        zkAppInstance.verify(
          id,
          creditScore,
          signature ?? fail('something is wrong with the signature')
        );
      });
      await txn.prove();
      await txn.send();

      const events = await zkAppInstance.fetchEvents();
      const verifiedEventValue = events[0].event.toFields(null)[0];
      expect(verifiedEventValue).toEqual(id);
    });

    it('throws an error if the credit score is below 700 even if the provided signature is valid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(2);
      const creditScore = Field(536);
      const signature = Signature.fromJSON({
        r:
          '25163915754510418213153704426580201164374923273432613331381672085201550827220',
        s:
          '20455871399885835832436646442230538178588318835839502912889034210314761124870',
      });

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });

    it('throws an error if the credit score is above 700 and the provided signature is invalid', async () => {
      const zkAppInstance = new OracleExample(zkAppAddress);
      await localDeploy(zkAppInstance, zkAppPrivateKey, deployerAccount);

      const id = Field(1);
      const creditScore = Field(787);
      const signature = Signature.fromJSON({
        r:
          '26545513748775911233424851469484096799413741017006352456100547880447752952428',
        s:
          '7381406986124079327199694038222605261248869991738054485116460354242251864564',
      });

      expect(async () => {
        await Mina.transaction(deployerAccount, () => {
          zkAppInstance.verify(
            id,
            creditScore,
            signature ?? fail('something is wrong with the signature')
          );
        });
      }).rejects;
    });
  });
});
```

Now save it and run `npm run test`.

You might have to try it twice in order for all the tests to pass because we're calling our live API directly. Note that writing a test that calls an API is generally not a best practice, but it’s convenient for the sake of this tutorial. You can also mock your HTTP requests.

Congratulations! You have just built a simple oracle using o1js and the Mina Protocol. You can find the complete code for this example [here](https://github.com/jackryanservia/oracle-example).

Checkout [Tutorial 8](custom-tokens) to learn how to launch and use custom tokens.
